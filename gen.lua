local fileName, mathFileName, easingsFileName = assert( select( 1, ... ))

local pp = require( 'pp' )
local converter = require( 'converter' )
local genfuncs = require( 'gen_functions' )

pp( '// Generated from ' .. fileName .. ', ' .. mathFileName, easingsFileName )

pp[[
// DO NOT EDIT BY HAND, AUTOGENERATED CONTENT
// Bindings for raylib https://github.com/raysan5/raylib
// Generator by iskolbin https://github.com/iskolbin/lraylib-gen

#define LUA_LIB
#include <stdlib.h>
#include <string.h>
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

#define RAYMATH_HEADER_ONLY
#include "raymath.h"

#include "easings.h"

#include "raylib.h"

#if(LUA_VERSION_NUM <= 501)
#define lua_raylib_tablelen lua_objlen
#define lua_raylib_register(L,l) luaL_register((L), NULL, (l))
#else
#define lua_raylib_tablelen lua_rawlen
#define lua_raylib_register(L,l) luaL_setfuncs((L), (l), 0)
#endif
]]


require( 'gen_struct' )( fileName )

local nFuncs, nUnimplemented, nUnimplenentedArgs, nUnimplementedReturns, implementedFunctionNames = genfuncs( fileName, 'RLAPI' )
for _, funcName in ipairs( require( 'gen_handmade' )) do
	implementedFunctionNames[#implementedFunctionNames+1] = funcName
end
local nFuncsMath, nUnimplementedMath, nUnimplenentedArgsMath, nUnimplementedReturnsMath, implementedFunctionNamesMath = genfuncs( mathFileName, 'RMDEF' )
local nFuncsEasings, nUnimplementedEasings, nUnimplenentedArgsEasings, nUnimplementedReturnsEasings, implementedFunctionNamesEasings = genfuncs( easingsFileName, 'EASEDEF' )
pp[[

static const luaL_Reg lua_raylib_functions[] = {]]
for _, funcName in ipairs( implementedFunctionNames ) do
	pp( '  {"${funcName}", lua_raylib_${funcName}},', {funcName = funcName} )
end
for _, funcName in ipairs( implementedFunctionNamesMath ) do
	pp( '  {"${funcName}", lua_raylib_${funcName}},', {funcName = funcName} )
end
for _, funcName in ipairs( implementedFunctionNamesEasings ) do
	pp( '  {"${funcName}", lua_raylib_${funcName}},', {funcName = funcName} )
end
for _, structName in ipairs( require( 'resources' ).resourcesList ) do
	pp( '  {"Get${structName}MetaTable", lua_raylib_${structName}_getmetatable},', {structName = structName} )
end
  pp[[
  {NULL, NULL}
};

LUAMOD_API int luaopen_raylib (lua_State *L) {]]
for _, struct in ipairs( require( 'resources' ).resourcesList ) do
  pp('  lua_raylib_' .. struct .. '_register(L);' )
end
  pp[[
  luaL_newlib(L, lua_raylib_functions);]]
	require( 'gen_constants' )( fileName )
pp([[
  return 1;
}

// Summary
// wrapped functions: ${nFuncs}, unimplemented: ${nUnimplemented}]], {nFuncs = nFuncs, nUnimplemented = nUnimplemented} )

if next( converter.UNIMPLEMETED_ARGS ) then
	pp( '// unimplemented argument conversions: ${nUnimplenentedArgs} functions', {nUnimplenentedArgs = nUnimplenentedArgs} )
end
for name in pairs( converter.UNIMPLEMETED_ARGS ) do
	print( '//', name )
end
if next( converter.UNIMPLEMENTED_RETURNS ) then
	pp( '// unimplemented return conversions: ${nUnimplementedReturns} functions', {nUnimplementedReturns = nUnimplementedReturns} )
end
for name in pairs( converter.UNIMPLEMENTED_RETURNS ) do
	print( '//', name )
end
