local resources = {
	'Image',
	'Texture2D',
	'RenderTexture2D',
	'Shader',
	'Font',
	'AudioStream',
	'Sound',
	'Music',
	'Mesh',
	'Model',
	'Material',
	'Wave',
	'TextureCubemap',
}

local aliases = {
	TextureCubemap = 'Texture'
}

local function isResource(t)
	for _, t_ in pairs(resources) do
		if t == t_ then
			return true
		end
	end
	return false
end

local function isResourceReference(r)
	local t = r:match('%s*%*?%s*(%w+)')
	if t then
		return isResource(t)
	else
		return false
	end
end

print[[
// DO NOT EDIT BY HAND, AUTOGENERATED CONTENT
// Bindings for raylib https://github.com/raysan5/raylib
// Generator by iskolbin https://github.com/iskolbin/lraylib-gen

#define LUA_LIB
#include <stdlib.h>
#include <string.h>
#include "raylib.h"
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

#define ISL_SLEEP_IMPLEMENTATION
#include "isl_sleep/isl_sleep.h"

static int isl_Sleep(lua_State *L) {
  int us = luaL_checkinteger(L, -1);
  isl_usleep(us);
  return 0;
}

typedef struct raylua_Storage {]]

-- Generate storage fields
for _, t in ipairs( resources ) do
	local name = t:sub(1,1):lower() .. t:sub(2)
	print((([[
  $T$ **$name$;
  int $name$Counter;
  int $name$Allocated;
  int *$name$Indices;
  int $name$IndicesCounter;
  int $name$IndicesAllocated;]]):gsub( '(%$%w+%$)', {
		['$T$'] = t,
		['$name$'] = name,
	})))
end

local function getReleaseFunction( t, v )
	t = aliases[t] or t
	if t ~= 'Mesh' then
		v = '*' .. v
	end
	if t == 'AudioStream' then
		return 'CloseAudioStream(' .. v .. ');'
	elseif t == 'Music' then
		return 'UnloadMusicStream(' .. v .. ');'
	else
		return'Unload' .. t:gsub( '2D', '' ) .. '(' .. v .. ');'
	end
end

print[[
} raylua_Storage;

// Init global storage for internal resources
static int raylua_InitStorage(lua_State *L)
{
  lua_getglobal(L, "__storage");
  if (!lua_isnil(L, -1))
    return luaL_error(L, "Global variable __storage is defined, probably storage was inited already");
  raylua_Storage *storage = malloc(sizeof * storage);
  memset(storage, 0, sizeof *storage);
  lua_pushlightuserdata(L, storage);
  lua_setglobal(L, "__storage" );
  return 1;
}

// Delete and free all storage resources
static int raylua_DeleteStorage(lua_State *L)
{
  lua_getglobal(L, "__storage");
  if (!lua_islightuserdata(L, -1))
    return luaL_error(L, "Global variable __storage is not light user data, probably "
		  "storage was not inited or already deleted");
  raylua_Storage *storage = lua_touserdata(L, -1);
  lua_pushnil(L);
  lua_setglobal(L, "__storage");]]

for _, t in ipairs( resources ) do
	local name = t:sub(1,1):lower() .. t:sub(2)
	print((([[
  for (int i = 0; i < storage->$name$Counter; i++)
  {
    if (storage->$name$[i] != NULL)
    {
      $releaseFunction$
      free(storage->$name$[i]);
    }
  }
  if (storage->$name$ != NULL) free(storage->$name$);
  if (storage->$name$Indices != NULL) free(storage->$name$Indices);
]]):gsub( '(%$%w+%$)', {
		['$name$'] = name,
		['$releaseFunction$'] = getReleaseFunction( t, 'storage->' .. name .. '[i]' )
	})))
end
print[[
  free(storage);
	return 0;
}]]

for _, t in ipairs(resources) do
	local name = t:sub(1,1):lower() .. t:sub(2)

	print((([[

static int raylua_Assoc$T$Handler(lua_State *L, $T$ *resource)
{
  int handler = -1;
  lua_getglobal(L, "__storage");
  if (!lua_islightuserdata(L, -1))
    return luaL_error(L, "Global variable __storage is not light user data, probably "
		  "storage was not inited or already deleted");
  raylua_Storage *storage = lua_touserdata(L, -1);
	if ($indicesCounter$ > 0) {
    handler = $indices$[--$indicesCounter$];
  }
  else
	{
    if ($itemsAllocated$ <= $itemsCounter$)
    {
      $T$ **tempItems = realloc($items$, 2 * sizeof * $items$);
      if (tempItems == NULL) return luaL_error(L, "Handlers for $T$ realloc failed");
      $items$ = tempItems;
      $itemsAllocated$ *= 2;
    }
    handler = $itemsCounter$++;
    $items$[handler] = malloc(sizeof *resource);
  }
  *$items$[handler] = *resource;
  return handler;
}

static $T$ *raylua_Deref$T$Handler(lua_State *L, int handler)
{
  lua_getglobal(L, "__storage");
  if (!lua_islightuserdata(L, -1))
  {
    luaL_error(L, "Global variable __storage is not light user data, probably "
      "storage was not inited or already deleted");
    return NULL;
  }
  raylua_Storage *storage = lua_touserdata(L, -1);
  if (handler < 0 || handler >= $itemsCounter$)
  {
    luaL_error(L, "$T$ handler out of bounds: %d", handler);
    return NULL;
  }
  return $items$[handler];
}

static int raylua_Release$T$(lua_State *L)
{
	int handler = luaL_checkinteger(L, -1);
	lua_getglobal(L, "__storage");
  if (!lua_islightuserdata(L, -1))
    return luaL_error(L, "Global variable __storage is not light user data, probably "
		  "storage was not inited or already deleted");
  raylua_Storage *storage = lua_touserdata(L, -1);
  if (handler < 0 || handler >= $itemsCounter$)
    luaL_error(L, "$T$ handler out of bounds: %d", handler);

  if ($indicesAllocated$ <= $indicesCounter$)
  {
    int *tempIndices = realloc($indices$, 2 * sizeof * $indices$);
    if (tempIndices == NULL)
      return luaL_error(L, "$T$ free indices realloc failed");
    $indices$ = tempIndices;
    $indicesAllocated$ *= 2;
  }
  $indices$[$indicesCounter$++] = handler;
	$itemsCounter$--;
  $releaseFunction$
  free($items$[handler]);
	$items$[handler] = NULL;
  return 0;
}]]):gsub('(%$%w+%$)', {
	['$T$'] = t,
	['$items$'] = 'storage->' .. name,
	['$itemsCounter$'] = 'storage->' .. name .. 'Counter',
	['$itemsAllocated$'] = 'storage->' .. name .. 'Allocated',
	['$indices$'] = 'storage->' .. name .. 'Indices',
	['$indicesCounter$'] = 'storage->' .. name .. 'IndicesCounter',
	['$indicesAllocated$'] = 'storage->' .. name .. 'IndicesAllocated',
	['$releaseFunction$'] = getReleaseFunction( t, 'storage->' .. name .. '[handler]' ),
})))
end

local function parseTypeName( body )
	local items = {}
	for item in body:gmatch( '%s?([%w%*]+)' ) do
		local frontStars, trimmedItem = item:match('(%**)(.+)')
		if #frontStars > 0 then
			items[#items+1] = frontStars
		end
		items[#items+1] = trimmedItem
	end
	return items[#items], table.concat( items, ' ', 1, #items-1 )
end

local UNIMPLEMETED_ARGS = {}

local function nCheckNumbers( index, n )
	local t = {}
	for i = 1, n do
		t[i] = 'luaL_checknumber(L, ' .. (index+i-1) .. ')'
	end
	return table.concat( t, ', ' )
end

local function formatResourceType( res )
	return res:match('%s*%*?%s*(%w+)')
end

local function argConvert( argType, index )
	if argType == 'int' or
		argType == 'unsigned' or
		argType == 'unsigned int' or
		argType == 'unsigned char' then
		return '(' .. argType .. ')luaL_checkinteger(L, ' .. index .. ')'
	elseif
		argType == 'long' or
		argType == 'float' or
		argType == 'double' or
		argType == 'char' or
		argType == 'bool' then
		return '(' .. argType .. ')luaL_checknumber(L, ' .. index .. ')'
	elseif argType == 'const char *' or argType == 'char *' then
		return '(' .. argType .. ') luaL_checkstring(L, ' .. index .. ')'
	elseif argType == 'Vector2' then
		return '(' .. argType .. ') {' .. nCheckNumbers(index, 2) .. '}', index+1
	elseif argType == 'Vector3' then
		return '(' .. argType .. ') {' .. nCheckNumbers(index, 3) .. '}', index+2
	elseif argType == 'Rectangle' then
		return '(' .. argType .. ') {' .. nCheckNumbers(index, 4) .. '}', index+3
	elseif argType == 'BoundingBox' or argType == 'Ray' or argType == 'Camera2D' then
		return '(' .. argType .. ') {' .. nCheckNumbers(index, 6) .. '}', index+5
	elseif argType == 'Matrix' then
		return '(' .. argType .. ') {' .. nCheckNumbers(index, 16) .. '}', index+15
	elseif argType == 'Camera' or argType == 'Camera3D' then
		return '(' .. argType .. ') {' .. nCheckNumbers(index, 11) .. '}', index+10
	elseif argType == 'Color' then
		return 'GetColor(luaL_checkinteger(L, ' .. index .. '))'
	elseif isResource( argType ) then
		return '*raylua_Deref' .. argType .. 'Handler(L, luaL_checkinteger(L, ' .. index .. '))'
	elseif isResourceReference( argType ) then
		return 'raylua_Deref' .. formatResourceType( argType ) .. 'Handler(L, luaL_checkinteger(L, ' .. index .. '))'
	else
		UNIMPLEMETED_ARGS[argType] = true
		return 'UNIMPLEMENTED_FOR_' .. argType, index, true
	end
end

local UNIMPLEMENTED_RETURNS = {}

local function pushNumbers( ... )
	local t = {}
	for i, arg in ipairs{...} do
		t[i] = 'lua_pushnumber(L, result.' .. arg ..')'
	end
	return table.concat( t, '; ' ), #t
end

local function returnConvert( returnType )
	if returnType == 'int' or
		returnType == 'unsigned' or
		returnType == 'unsigned int' or
		returnType == 'char' then
		return 'lua_pushinteger(L, result)'
	elseif returnType == 'long' or
		returnType == 'float' or
		returnType == 'double' then
		return 'lua_pushnumber(L, result)'
	elseif returnType == 'const char *' or returnType == 'char *' then
		return 'lua_pushstring(L, result)'
	elseif returnType == 'bool' then
		return 'lua_pushboolean(L, result)'
	elseif returnType == 'Color' then
		return 'lua_pushinteger(L, ColorToInt(result))'
	elseif returnType == 'Vector2' then
		return pushNumbers( 'x', 'y' )
	elseif returnType == 'Vector3' then
		return pushNumbers( 'x', 'y', 'z' )
	elseif returnType == 'Vector4' then
		return pushNumbers( 'x', 'y', 'z', 'w' )
	elseif returnType == 'Rectangle' then
		return pushNumbers('x', 'y', 'width', 'height')
	elseif returnType == 'BoundingBox' then
		return pushNumbers( 'min.x', 'min.y', 'min.z', 'max.x', 'max.y', 'max.z' )
	elseif returnType == 'Ray' then
		return pushNumbers( 'position.x', 'position.y', 'position.z', 'direction.x', 'direction.y', 'direction.z' )
	elseif returnType == 'Matrix' then
		return pushNumbers(
		'm0', 'm4', 'm8', 'm12',
		'm1', 'm5', 'm9', 'm13',
		'm2', 'm6', 'm10', 'm14',
		'm3', 'm7', 'm11', 'm15' )
	elseif returnType == 'RayHitInfo' then
		return pushNumbers( 'hit', 'distance', 'position.x', 'position.y', 'position.z', 'normal.x', 'normal.y', 'normal.z' )
	elseif isResource( returnType ) then
		return 'lua_pushinteger(L, raylua_Assoc' .. returnType .. 'Handler(L, &result))'
	else
		UNIMPLEMENTED_RETURNS[returnType] = true
		return 'UNIMPLEMENTED_FOR_' .. returnType .. '(L, result)', 1, true
	end
end

local nFuncs, nUnimplemented, nUnimplenentedArgs, nUnimplementedReturns = 0, 0, 0, 0


local BLACKLIST = {
	GetDirectoryFiles = true, -- returns const char **
	GetDroppedFiles = true, -- returns const char **
	UpdateCamera = true, -- nothing to update actually
	UpdateVrTracking = true, -- nothing to update actually
	GetWindowHandle = true,
	UpdateTexture = true,

	SetTraceLogLevel = true,
	SetTraceLogExit = true,
	SetTraceLogCallback = true,
	TraceLog = true,

	GetWaveData = true, -- need output arrays
	DrawPolyEx = true, -- need input arrays
	DrawPolyExLines = true, -- need input arrays
	LoadImageEx = true, -- need input arrays
	LoadImagePro = true,
	GetImageData = true,
	GetImageDataNormalized = true,
	ImageExtractPalette = true, -- need output arrays
	LoadFontData = true,
	LoadWaveEx = true,
	UpdateSound = true,

	SetShaderValue = true,
	SetShaderValueV = true,

	-- Redundant functions
	DrawPixelV = true,
	DrawLineV = true,
	DrawCircleV = true,
	DrawCubeWiresV = true,
	DrawCubeV = true,
	DrawRectangleV = true,
	DrawRectangleRec = true,
	TextIsEqual = true,
	TextLength = true,
	TextFormat = true,
	TextSubtext = true,
	TextReplace = true,
	TextInsert = true,
	TextJoin = true,
	TextSplit = true,
	TextAppend = true,
	TextFindIndex = true,
	TextToUpper = true,
	TextToLower = true,
	TextToPascal = true,
	TextToInteger = true
}

-- Parse functions
local s = nil
local implementedFunctionNames = {}
for line in io.lines(...) do
	-- Multiline support
	if s then
		s = s:sub(1,-2) .. line
	end
	if line:sub(1,5) == 'RLAPI' then
		s = line
	end

	if s and s:match(';') then
		-- Varargs (not implemented)
		local varargIndex
		s, varargIndex = s:gsub('%,%s%.%.%.', '')
		local funcVararg = varargIndex > 0

		local bodyName, bodyArgs, comment = s:match( 'RLAPI (.+)%((.-)%);%s*//%s*(.+)' )
		-- Parse function name and return type
		local funcName, funcReturnType = parseTypeName( bodyName )

		local funcCode = {}
		if not BLACKLIST[funcName] then
			-- Parse function arguments and their types
			local funcArgs, funcArgsNames = {}, {}
			if bodyArgs ~= 'void' then
				for bodySingleArg in bodyArgs:gmatch( '([%w%s%*]+)' ) do
					funcArgs[#funcArgs+1] = {parseTypeName( bodySingleArg )}
					funcArgsNames[#funcArgsNames+1] = funcArgs[#funcArgs][1]
				end
			end
			nFuncs = nFuncs + 1
			funcCode[#funcCode+1] = ( '\n// ' .. comment )
			funcCode[#funcCode+1] = ( 'static int raylua_' .. funcName ..'(lua_State *L)' )
			funcCode[#funcCode+1] = ( '{' )
			local i, unimplementedArgConvert, unimplemented = 0, false, false
			for _, arg in ipairs( funcArgs ) do
				i = i + 1
				local argName, argType = arg[1], arg[2]
				local converted, j, unimplementedCurrentArgConvert = argConvert( argType, i )
				if j and j > i then
					i = j
				end
				unimplementedArgConvert = unimplementedArgConvert or unimplementedCurrentArgConvert
				funcCode[#funcCode+1] = ( '  ' .. argType .. ' ' .. argName .. ' = ' .. converted .. ';' )
			end
			local result, resultCount = funcReturnType .. ' result = ', 1
			if funcReturnType == 'void' then
				result, resultCount = '', 0
			end
			funcCode[#funcCode+1] = ( '  ' .. result .. funcName .. '(' .. table.concat( funcArgsNames, ', ' ) .. ');')

			if unimplementedArgConvert then
				nUnimplenentedArgs = nUnimplenentedArgs + 1
				unimplemented = true
			end

			if resultCount > 0 then
				local convertedResult, newCount, unimplementedReturn = returnConvert( funcReturnType )
				if newCount and newCount > 1 then
					resultCount = newCount
				end
				funcCode[#funcCode+1] = ( '  ' .. convertedResult ..';' )

				if unimplementedReturn then
					nUnimplementedReturns = nUnimplementedReturns + 1
					unimplemented = true
				end
			end

			if funcVararg then
				unimplemented = true
			end

			if unimplemented then
				nUnimplemented = nUnimplemented + 1
			end

			funcCode[#funcCode+1] = ( '  return ' .. resultCount .. ';')
			funcCode[#funcCode+1] = ( '}' )
			if unimplemented then
				print('// ' .. funcName .. ' is not implemented' )
			else
				implementedFunctionNames[#implementedFunctionNames+1] = funcName
				print( table.concat( funcCode, '\n' ))
			end
		end
		s = nil
	end
end

print[[
static const luaL_Reg raylua_functions[] = {
  {"InitStorage", raylua_InitStorage},
  {"DeleteStorage", raylua_DeleteStorage},
	{"Sleep", isl_Sleep},]]
for _, funcName in ipairs( implementedFunctionNames ) do
	print( '  {"' .. funcName .. '", raylua_' .. funcName .. '},' )
end
for _, resName in ipairs( resources ) do
	print( '  {"Release' .. resName ..'", raylua_Release' .. resName .. '},' )
end
print[[
  {NULL, NULL}
};

LUAMOD_API int luaopen_raylib (lua_State *L) {
  luaL_newlib(L, raylua_functions);]]

-- Parse enums and colors
local prevValue
for line in io.lines(...) do
	local name, value = line:match( '%s*([%u%d_]+)%s*=%s*(%d+)' )
	if name and value then
		prevValue = tonumber(value)
		print( '  lua_pushnumber(L, ' .. tonumber(value) ..'); lua_setfield(L, -2, "' .. name .. '");' )
	elseif prevValue and not line:match(';') then
		name = line:match( '([%u%d_]+)' )
		if name then
			prevValue = prevValue + 1
			print( '  lua_pushnumber(L, ' .. prevValue .. '); lua_setfield(L, -2, "' .. name .. '");' )
		else
			prevValue = nil
		end
	end

	local colorName, r, g, b, a = line:match( '#define%s+([%u_]+)%s+CLITERAL%{ (%d+), (%d+), (%d+), (%d+) }' )
	if colorName then
		local rgba = math.floor( tonumber(r) * 2^24 + tonumber(g) * 2^16 + tonumber(b) * 2^8 + tonumber(a))
		print( '  lua_pushinteger(L, ' .. rgba .. '); lua_setfield(L, -2, "' .. colorName .. '");' )
	end
end

print( '  return 1;' )
print( '}' )

print( '// Summary' )
print( '// wrapped functions: ' .. nFuncs .. ', unimplemented: ' .. nUnimplemented )
if next( UNIMPLEMETED_ARGS ) then
	print( '// unimplemented argument conversions: ' .. nUnimplenentedArgs .. ' functions' )
end
for name in pairs( UNIMPLEMETED_ARGS ) do
	print( '//', name )
end
if next( UNIMPLEMENTED_RETURNS ) then
	print( '// unimplemented return conversions: ' .. nUnimplementedReturns .. ' functions' )
end
for name in pairs( UNIMPLEMENTED_RETURNS ) do
	print( '//', name )
end
