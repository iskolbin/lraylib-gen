local resources = {
	'Image',
	'Texture2D',
	'RenderTexture2D',
	'Shader',
	'Font',
	'AudioStream',
	'Sound',
	'Music',
	'Mesh',
	'Model',
	'Material',
	'Wave',
	'TextureCubemap',
}

local aliases = {
	TextureCubemap = 'Texture'
}

local function pp( str, substitutesTable )
	local s = (str:gsub( '%$%{(%w-)%}', substitutesTable))
	print(s)
end

local function isResource(t)
	for _, t_ in pairs(resources) do
		if t == t_ then
			return true
		end
	end
	return false
end

pp([[
// DO NOT EDIT BY HAND, AUTOGENERATED CONTENT
// Bindings for raylib https://github.com/raysan5/raylib
// Generator by iskolbin https://github.com/iskolbin/lraylib-gen

#define LUA_LIB
#include <stdlib.h>
#include <string.h>
#include "raylib.h"
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

#define ISL_SLEEP_IMPLEMENTATION
#include "isl_sleep/isl_sleep.h"

static int isl_Sleep(lua_State *L) {
  int us = luaL_checkinteger(L, -1);
  isl_usleep(us);
  return 0;
}]], {})

local function getReleaseFunction( t, v )
	t = aliases[t] or t
	if t ~= 'Mesh' then
		v = '*' .. v
	end
	if t == 'AudioStream' then
		return 'CloseAudioStream(' .. v .. ');'
	elseif t == 'Music' then
		return 'UnloadMusicStream(' .. v .. ');'
	else
		return'Unload' .. t:gsub( '2D', '' ) .. '(' .. v .. ');'
	end
end

local function parseTypeName( body )
	local items = {}
	for item in body:gmatch( '%s?([%w%*]+)' ) do
		local frontStars, trimmedItem = item:match('(%**)(.+)')
		if #frontStars > 0 then
			items[#items+1] = frontStars
		end
		items[#items+1] = trimmedItem
	end
	return items[#items], table.concat( items, ' ', 1, #items-1 )
end

local UNIMPLEMETED_ARGS = {}

local function nCheckNumbers( index, n )
	local t = {}
	for i = 1, n do
		t[i] = 'luaL_checknumber(L, ' .. (index+i-1) .. ')'
	end
	return table.concat( t, ', ' )
end

local function formatResourceType( res )
	return res:match('%s*%*?%s*(%w+)')
end

local function argConvert( argType, index )
	print( 'ARG CONVERT', argType )
	if argType == 'int' or argType == 'unsigned' or argType == 'unsigned int' or argType == 'unsigned char' then
		return '(' .. argType .. ') luaL_checkinteger(L, ' .. index .. ')'
	elseif argType == 'long' or argType == 'float' or argType == 'double' or argType == 'char' or argType == 'bool' then
		return '(' .. argType .. ') luaL_checknumber(L, ' .. index .. ')'
	elseif argType == 'const char *' or argType == 'char *' then
		return '(' .. argType .. ') luaL_checkstring(L, ' .. index .. ')'
	elseif argType == 'Vector2' then
		return '(' .. argType .. ') {' .. nCheckNumbers(index, 2) .. '}', index+1
	elseif argType == 'Vector3' then
		return '(' .. argType .. ') {' .. nCheckNumbers(index, 3) .. '}', index+2
	elseif argType == 'Rectangle' then
		return '(' .. argType .. ') {' .. nCheckNumbers(index, 4) .. '}', index+3
	elseif argType == 'BoundingBox' or argType == 'Ray' or argType == 'Camera2D' then
		return '(' .. argType .. ') {' .. nCheckNumbers(index, 6) .. '}', index+5
	elseif argType == 'Matrix' then
		return '(' .. argType .. ') {' .. nCheckNumbers(index, 16) .. '}', index+15
	elseif argType == 'Camera' or argType == 'Camera3D' then
		return '(' .. argType .. ') {' .. nCheckNumbers(index, 11) .. '}', index+10
	elseif argType == 'Color' then
		return 'GetColor(luaL_checkinteger(L, ' .. index .. '))'
	elseif isResource( argType ) then

	else
		UNIMPLEMETED_ARGS[argType] = true
		return 'UNIMPLEMENTED_FOR_' .. argType, index, true
	end
end

local UNIMPLEMENTED_RETURNS = {}

local function pushNumbers( ... )
	local t = {}
	for i, arg in ipairs{...} do
		t[i] = 'lua_pushnumber(L, result.' .. arg ..')'
	end
	return table.concat( t, '; ' ), #t
end

local function returnConvert( returnType )
	if returnType == 'int' or
		returnType == 'unsigned' or
		returnType == 'unsigned int' or
		returnType == 'char' then
		return 'lua_pushinteger(L, result)'
	elseif returnType == 'long' or
		returnType == 'float' or
		returnType == 'double' then
		return 'lua_pushnumber(L, result)'
	elseif returnType == 'const char *' or returnType == 'char *' then
		return 'lua_pushstring(L, result)'
	elseif returnType == 'bool' then
		return 'lua_pushboolean(L, result)'
	elseif returnType == 'Color' then
		return 'lua_pushinteger(L, ColorToInt(result))'
	elseif returnType == 'Vector2' then
		return pushNumbers( 'x', 'y' )
	elseif returnType == 'Vector3' then
		return pushNumbers( 'x', 'y', 'z' )
	elseif returnType == 'Vector4' then
		return pushNumbers( 'x', 'y', 'z', 'w' )
	elseif returnType == 'Rectangle' then
		return pushNumbers('x', 'y', 'width', 'height')
	elseif returnType == 'BoundingBox' then
		return pushNumbers( 'min.x', 'min.y', 'min.z', 'max.x', 'max.y', 'max.z' )
	elseif returnType == 'Ray' then
		return pushNumbers( 'position.x', 'position.y', 'position.z', 'direction.x', 'direction.y', 'direction.z' )
	elseif returnType == 'Matrix' then
		return pushNumbers(
		'm0', 'm4', 'm8', 'm12',
		'm1', 'm5', 'm9', 'm13',
		'm2', 'm6', 'm10', 'm14',
		'm3', 'm7', 'm11', 'm15' )
	elseif returnType == 'RayHitInfo' then
		return pushNumbers( 'hit', 'distance', 'position.x', 'position.y', 'position.z', 'normal.x', 'normal.y', 'normal.z' )
	elseif isResource( returnType ) then
		return 'lua_pushinteger(L, raylua_Assoc' .. returnType .. 'Handler(L, &result))'
	else
		UNIMPLEMENTED_RETURNS[returnType] = true
		return 'UNIMPLEMENTED_FOR_' .. returnType .. '(L, result)', 1, true
	end
end

local nFuncs, nUnimplemented, nUnimplenentedArgs, nUnimplementedReturns = 0, 0, 0, 0


local BLACKLIST = {
	GetDirectoryFiles = true, -- returns const char **
	GetDroppedFiles = true, -- returns const char **
	UpdateCamera = true, -- nothing to update actually
	UpdateVrTracking = true, -- nothing to update actually
	GetWindowHandle = true,
	UpdateTexture = true,

	SetTraceLogLevel = true,
	SetTraceLogExit = true,
	SetTraceLogCallback = true,
	TraceLog = true,

	GetWaveData = true, -- need output arrays
	DrawPolyEx = true, -- need input arrays
	DrawPolyExLines = true, -- need input arrays
	LoadImageEx = true, -- need input arrays
	LoadImagePro = true,
	GetImageData = true,
	GetImageDataNormalized = true,
	ImageExtractPalette = true, -- need output arrays
	LoadFontData = true,
	LoadWaveEx = true,
	UpdateSound = true,

	SetShaderValue = true,
	SetShaderValueV = true,

	-- Redundant functions
	DrawPixelV = true,
	DrawLineV = true,
	DrawCircleV = true,
	DrawCubeWiresV = true,
	DrawCubeV = true,
	DrawRectangleV = true,
	DrawRectangleRec = true,
	TextIsEqual = true,
	TextLength = true,
	TextFormat = true,
	TextSubtext = true,
	TextReplace = true,
	TextInsert = true,
	TextJoin = true,
	TextSplit = true,
	TextAppend = true,
	TextFindIndex = true,
	TextToUpper = true,
	TextToLower = true,
	TextToPascal = true,
	TextToInteger = true
}

-- Parse functions
local s = nil
local implementedFunctionNames = {}
for line in io.lines(...) do
	-- Multiline support
	if s then
		s = s:sub(1,-2) .. line
	end
	if line:sub(1,5) == 'RLAPI' then
		s = line
	end

	if s and s:match(';') then
		-- Varargs (not implemented)
		local varargIndex
		s, varargIndex = s:gsub('%,%s%.%.%.', '')
		local funcVararg = varargIndex > 0

		local bodyName, bodyArgs, comment = s:match( 'RLAPI (.+)%((.-)%);%s*//%s*(.+)' )
		-- Parse function name and return type
		local funcName, funcReturnType = parseTypeName( bodyName )

		local funcCode = {}
		if not BLACKLIST[funcName] then
			-- Parse function arguments and their types
			local funcArgs, funcArgsNames = {}, {}
			if bodyArgs ~= 'void' then
				for bodySingleArg in bodyArgs:gmatch( '([%w%s%*]+)' ) do
					funcArgs[#funcArgs+1] = {parseTypeName( bodySingleArg )}
					funcArgsNames[#funcArgsNames+1] = funcArgs[#funcArgs][1]
				end
			end
			nFuncs = nFuncs + 1
			funcCode[#funcCode+1] = ( '\n// ' .. comment )
			funcCode[#funcCode+1] = ( 'static int raylua_' .. funcName ..'(lua_State *L)' )
			funcCode[#funcCode+1] = ( '{' )
			local i, unimplementedArgConvert, unimplemented = 0, false, false
			for _, arg in ipairs( funcArgs ) do
				i = i + 1
				local argName, argType = arg[1], arg[2]
				print( 'ARGNAME', argName, argType )
				local converted, j, unimplementedCurrentArgConvert = argConvert( argType, i )
				print('CONVERTED', converted, j, unimplementedCurrentArgConvert)
				if j and j > i then
					i = j
				end
				unimplementedArgConvert = unimplementedArgConvert or unimplementedCurrentArgConvert
				funcCode[#funcCode+1] = ( '  ' .. argType .. ' ' .. argName .. ' = ' .. converted .. ';' )
			end
			local result, resultCount = funcReturnType .. ' result = ', 1
			if funcReturnType == 'void' then
				result, resultCount = '', 0
			end
			funcCode[#funcCode+1] = ( '  ' .. result .. funcName .. '(' .. table.concat( funcArgsNames, ', ' ) .. ');')

			if unimplementedArgConvert then
				nUnimplenentedArgs = nUnimplenentedArgs + 1
				unimplemented = true
			end

			if resultCount > 0 then
				local convertedResult, newCount, unimplementedReturn = returnConvert( funcReturnType )
				if newCount and newCount > 1 then
					resultCount = newCount
				end
				funcCode[#funcCode+1] = ( '  ' .. convertedResult ..';' )

				if unimplementedReturn then
					nUnimplementedReturns = nUnimplementedReturns + 1
					unimplemented = true
				end
			end

			if funcVararg then
				unimplemented = true
			end

			if unimplemented then
				nUnimplemented = nUnimplemented + 1
			end

			funcCode[#funcCode+1] = ( '  return ' .. resultCount .. ';')
			funcCode[#funcCode+1] = ( '}' )
			if unimplemented then
				pp('// ${funcName} is not implemented', {funcName = funcName} )
			else
				implementedFunctionNames[#implementedFunctionNames+1] = funcName
				print( table.concat( funcCode, '\n' ))
			end
		end
		s = nil
	end
end

pp[[
static const luaL_Reg raylua_functions[] = {
  {"InitStorage", raylua_InitStorage},
  {"DeleteStorage", raylua_DeleteStorage},
	{"Sleep", isl_Sleep},]]
for _, funcName in ipairs( implementedFunctionNames ) do
	pp( '  {"${funcName}", raylua_${funcName}},', {funcName = funcName} )
end
pp[[
  {NULL, NULL}
};

LUAMOD_API int luaopen_raylib (lua_State *L) {
  luaL_newlib(L, raylua_functions);]]

-- Parse enums and colors
local prevValue
for line in io.lines(...) do
	local name, value = line:match( '%s*([%u%d_]+)%s*=%s*(%d+)' )
	if name and value then
		prevValue = tonumber(value)
		pp( '  lua_pushnumber(L, ${value}); lua_setfield(L, -2, "${name}");', {value = tonumber(value), name = name} )
	elseif prevValue and not line:match(';') then
		name = line:match( '([%u%d_]+)' )
		if name then
			prevValue = prevValue + 1
			pp( '  lua_pushnumber(L, ${prevValue}); lua_setfield(L, -2, "${name}");', {prevValue = prevValue, name = name} )
		else
			prevValue = nil
		end
	end

	local colorName, r, g, b, a = line:match( '#define%s+([%u_]+)%s+CLITERAL%{ (%d+), (%d+), (%d+), (%d+) }' )
	if colorName then
		local rgba = math.floor( tonumber(r) * 2^24 + tonumber(g) * 2^16 + tonumber(b) * 2^8 + tonumber(a))
		pp( '  lua_pushinteger(L, ${rgba}); lua_setfield(L, -2, "${colorName}");', {rgba = rgba, colorName = colorName} )
	end
end

pp([[
  return 1;
}

// Summary
// wrapped functions: ${nFuncs}, unimplemented: ${nUnimplemented}]], {nFuncs = nFuncs, nUnimplemented = nUnimplemented} )
if next( UNIMPLEMETED_ARGS ) then
	pp( '// unimplemented argument conversions: ${nUnimplenentedArgs} functions', {nUnimplenentedArgs = nUnimplenentedArgs} )
end
for name in pairs( UNIMPLEMETED_ARGS ) do
	print( '//', name )
end
if next( UNIMPLEMENTED_RETURNS ) then
	print( '// unimplemented return conversions: ${nUnimplementedReturns} functions', {nUnimplementedReturns = nUnimplementedReturns} )
end
for name in pairs( UNIMPLEMENTED_RETURNS ) do
	print( '//', name )
end
