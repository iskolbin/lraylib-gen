local isInt = {
	['int'] = true, ['unsigned'] = true, ['unsigned int'] = true,
	['signed int'] = true, ['signed'] = true,
	['short int'] = true, ['unsigned short'] = true, ['unsigned short int'] = true,
	['signed short int'] = true, ['signed short'] = true,
	['char'] = true, ['unsigned char'] = true, ['signed char'] = true,
}

local isNumber = {
	['long'] = true, ['unsigned long'] = true, ['unsigned long int'] = true,
	['signed long'] = true, ['signed long int'] = true,
	['float'] = true, ['double'] = true,
}

local function tolua( T, name )
	name = name or 'result'
	if isInt[T] then
		return 'lua_pushinteger(L, ' .. name .. ')'
	elseif isNumber[T] then
		return 'lua_pushnumber(L, ' .. name .. ')'
	elseif T == 'const char *' or T == 'char *'  or T == 'const char*' or T == 'char*' then
		return 'lua_pushstring(L, ' .. name .. ')'
	elseif T == 'bool' then
		return 'lua_pushboolean(L, ' .. name .. ')'
	elseif T == 'void *' or T == 'const void *' or T == 'void*' or T == 'const void*' then
		return 'lua_pushlightuserdata(L, ' .. name .. ')'
	else
		local Tref = T:match( '(%w+)%s*%*' )
		if Tref then
			return Tref .. '* userdata = lua_newuserdata(L, sizeof *userdata); *userdata = *' .. name .. '; luaL_setmetatable(L, "' .. Tref .. '")'
		else
			return T .. '* userdata = lua_newuserdata(L, sizeof *userdata); *userdata = ' .. name .. '; luaL_setmetatable(L, "' .. T .. '")'
		end
	end
end

local function fromlua( T, index, primitiveFields )
	if isInt[T] then
		return 'luaL_checkinteger(L, ' .. index .. ')'
	elseif isNumber[T] then
		return 'luaL_checknumber(L, ' .. index .. ')'
	elseif T == 'const char *' or T == 'char *' or T == 'const char*' or T == 'char*' then
		return 'luaL_checkstring(L, ' .. index .. ')'
	elseif T == 'bool' then
		return 'luaL_checknumber(L, ' .. index .. ')'
	elseif T == 'void *' or T == 'const void *' or T == 'void*' or T == 'const void*' then
		return 'luaX_checklightuserdata(L, ' .. index .. ', "?")'
	else
		local Tref = T:match( '(%w+)%s*%*' )
		if Tref then
			return '(' .. Tref .. '*)luaL_checkudata(L, ' .. index .. ', "' .. Tref .. '")'
		else
			return '(*(' .. T .. '*)luaL_checkudata(L, ' .. index .. ', "' .. T .. '"))'
		end
	end
end

local function merge( t, tomerge )
	for k, v in pairs( tomerge ) do
		if type( v ) == 'table' and type( t[k] ) == 'table' then
			t[k] = merge( t[k], v )
		else
			t[k] = v
		end
	end
	return t
end

return function( conf, defs, custom )
	if custom then
		defs = merge( defs, custom )
	end

	local aliases = defs.aliases or {}
	local function unalias( t )
		if not t then return t end
		local t, count = t:gsub( '%*', '' )
		return (aliases[t] or t) .. ('*'):rep( count )
	end

	-- Primitive sturcts are structs with primitive fields only, Vector2 for instance
	local isPrimitiveStruct = {}
	for structName, structFields in pairs( defs.structs ) do
		structName = unalias( structName )
		local primitive = true
		for _, name_T_length in ipairs( structFields ) do
			local name, T, length = name_T_length[1], name_T_length[2], name_T_length[3]
			if length or (not isInt[T] and not isNumber[T]) then
				primitive = false
			end
		end
		if primitive then
			isPrimitiveStruct[structName] = structFields
		end
	end
	local prefix = conf.prefix
	print( '// Autogenerated library bindings ' .. conf.libname .. ' from ' .. defs.header )
	print( '// Generator by iskolbin https://github.com/iskolbin/lraylib-gen' )
	print()
	print( '#include <stdlib.h>' )
	print()
	print( '#define LUA_LIB' )
	print( '#include <lua.h>' )
	print( '#include <lauxlib.h>' )
	print( '#include <lualib.h>' )
	for _, define in ipairs( conf.defines or {} ) do
		print( '#define ' .. define )
	end
	for _, include in ipairs( conf.includes or {} ) do
		print( '#include "' .. include .. '"' )
	end
	print()
	print( '// Lua 5.1 compatibility' )
	print( '#if (LUA_VERSION_NUM <= 501)' )
	print( '#define LUAMOD_API LUALIB_API' )
	print( '#define luaL_newlib(L,lib) luaL_register(L,"' .. conf.libname .. '",lib)' )
	print( '#define luaL_setfuncs(L,l,z) luaL_register(L,NULL,l)' )
	print( '#define luaL_setmetatable(L,mt) luaL_getmetatable(L,mt);lua_setmetatable(L,-2)' )
	print( '#define lua_rawlen lua_objlen' )
	print( '#endif' )
	print()
	print( 'static void * luaX_checklightuserdata(lua_State *L, int index, const char *funcName) {' )
	print( '  if (lua_islightuserdata(L, index)) {' )
	print( '    return lua_touserdata(L, index);' )
	print( '  } else {' )
	print( '    luaL_error(L, "bad argument #%d to %s (lightuserdata expected, got %s)", index, funcName, lua_typename(L, index));' )
	print( '    return NULL;' )
	print( '  }' )
	print( '}' )
	print()
	local funcNames = {}
	local unpackedFuncNames = {}
	for funcName, f in pairs( defs.funcs ) do
		local returns = unalias( f.returns )
		local hasPrimitives = isPrimitiveStruct[returns]
		funcNames[#funcNames+1] = funcName
		if f.comment then
			print( '// ' .. f.comment )
		end
		print( 'static int ' .. prefix .. funcName .. '(lua_State *L) {' )
		if f.blacklisted then
			print( 'return luaL_error(L, "' .. funcName .. ' is blacklisted");' )
		elseif f.src then
			print( f.src )
		else
			if (not f.args or #f.args == 0) and not returns then
				print( '  (void)L; // Suppress unused warning' )
			end
			local argNames = {}
			for i, name_type in ipairs( f.args or {} ) do
				local argName, argType = name_type[1], name_type[2]
				argType = unalias( argType )
				if isPrimitiveStruct[argType] then
					hasPrimitives = true
				end
				argNames[i] = argName
				local argConverter = fromlua( argType, i )
				print( '  ' .. argType .. ' ' .. argName .. ' = ' .. argConverter .. ';' )
			end
			if returns then
				print( '  ' .. returns .. ' result = ' .. funcName .. '(' .. table.concat( argNames, ', ' ) .. ');' )
				local returnConverter, returnCount = tolua( returns, nil, isPrimitiveStruct[returns] )
				print( '  ' .. returnConverter .. ';' )
				if f.resultFinalizer then
					print( '  ' .. f.resultFinalizer .. ';' )
				end
				print( '  return ' .. (returnCount or 1) .. ';' )
			else
				print( '  ' .. funcName .. '(' .. table.concat( argNames, ', ' ) .. ');' )
				print( '  return 0;' )
			end
		end
		print( '}' )
		print()

		-- Unpacked primitive arguments/returns version
		if hasPrimitives then
			local funcNameU = funcName .. 'U'
			unpackedFuncNames[#unpackedFuncNames+1] = funcNameU
			if f.comment then
				print( '// ' .. f.comment .. ' (unpacked version)' )
			end
			print( 'static int ' .. prefix .. funcNameU .. '(lua_State *L) {' )
			if f.blacklisted then
				print( 'return luaL_error(L, "' .. funcNameU .. ' is blacklisted");' )
			elseif f.src then
				print( f.src )
			else
				if (not f.args or #f.args == 0) and not returns then
					print( '  (void)L; // Suppress unused warning' )
				end
				local argNames = {}
				local index = 0
				for _, name_type in ipairs( f.args or {} ) do
					index = index + 1
					local argName, argType = name_type[1], name_type[2]
					argNames[#argNames+1] = argName
					argType = unalias( argType )
					if isPrimitiveStruct[argType] then
						local argsU = {}
						for i, name_type in ipairs( isPrimitiveStruct[argType] ) do
							argsU[#argsU+1] = fromlua( name_type[2], index + i - 1 )
						end
						print( '  ' .. argType .. ' ' .. argName .. ' = {' .. table.concat( argsU, ',' ) .. '};' )
						index = index + #isPrimitiveStruct[argType] - 1
					else
						local argConverter = fromlua( argType, index )
						print( '  ' .. argType .. ' ' .. argName .. ' = ' .. argConverter .. ';' )
					end
				end
				if returns then
					print( '  ' .. returns .. ' result = ' .. funcName .. '(' .. table.concat( argNames, ', ' ) .. ');' )
					local returnConverter, returnCount = tolua( returns )
					print( '  ' .. returnConverter .. ';' )
					if f.resultFinalizer then
						print( '  ' .. f.resultFinalizer .. ';' )
					end
					print( '  return ' .. (returnCount or 1) .. ';' )
				else
					print( '  ' .. funcName .. '(' .. table.concat( argNames, ', ' ) .. ');' )
					print( '  return 0;' )
				end
			end
			print( '}' )
			print()
		end
	end

	-- Constructors for structs, for any structs zero constructor is exposed
	for structName, structFields in pairs( defs.structs ) do
		structName = unalias( structName )
		print( 'static int ' .. prefix .. structName .. '_new(lua_State *L) {' )
		print( '  ' .. structName .. '* obj = lua_newuserdata(L, sizeof *obj); luaL_setmetatable(L, "' .. structName .. '");' )
		print( '  if (lua_gettop(L) == 1) {' )
		print( '   ' .. structName .. ' temp = {};' )
		print( '    *obj = temp;' )
		-- for primitive structs init-all-fields consturctor is also possible
		if isPrimitiveStruct[structName] then
			print( '  } else {' )
			for i, fieldName_Type in ipairs( structFields ) do
				local fieldName, fieldType = fieldName_Type[1], fieldName_Type[2]
				fieldType = unalias( fieldType )
				print( '    obj->' .. fieldName .. ' = ' .. fromlua( fieldType, i ) .. ';' )
			end
		end
		print( '  }' )
		print( '  return 1;' )
		print( '}' )
		print()
	end

	print( 'static const luaL_Reg ' .. prefix .. 'functions[] = {' )
	-- Add module functions
	for _, funcName in ipairs( funcNames ) do
		print( '  {"' .. funcName .. '", ' .. prefix .. funcName .. '},' )
	end
	-- Add unpacked primitive args/return functions
	for _, funcName in ipairs( unpackedFuncNames ) do
		print( '  {"' .. funcName .. '", ' .. prefix .. funcName .. '},' )
	end
	-- Add constructors for structs
	for structName in pairs( defs.structs ) do
		structName = unalias( structName )
		print( '  {"' .. structName .. '", ' .. prefix .. structName .. '_new},' )
	end
	print( '  {NULL, NULL}' )
	print( '};' )
	print()

	-- Generate metatables for structs
	for structName, structFields in pairs( defs.structs ) do
		structName = unalias( structName )
		local primitiveFields = isPrimitiveStruct[structName]
		if primitiveFields then
			-- Primitive structs have proper equality check
			print( 'static int ' .. prefix .. structName .. '__eq(lua_State *L) {' )
			print( '  lua_getmetatable(L, 1); lua_getmetatable(L, 2);' )
			print( '  if (lua_rawequal(L, -1, -2) == 0) {' )
			print( '    lua_pushboolean(L, 0);' )
			print( '  } else {' )
			print( '    ' .. structName .. ' *self = lua_touserdata(L, 1);' )
			print( '    ' .. structName .. ' *other = lua_touserdata(L, 2);' )
			io.write(   '    lua_pushboolean(L, ' )
			for i, fieldName_Type in ipairs( primitiveFields ) do
				io.write( i > 1 and ' && ' or '', 'self->', fieldName_Type[1], ' == other->', fieldName_Type[1] )
			end
			print( ');' )
			print( '  }' )
			print( '  return 1;' )
			print( '}' )
			print()
			-- Primitive structs have unpack method
			print( 'static int ' .. prefix .. structName .. '_unpack(lua_State *L) {' )
			print( '  ' .. structName .. ' *self = luaL_checkudata(L, 1, "' .. structName .. '");' )
			for i, fieldName_Type in ipairs( primitiveFields ) do
				print( '  ' .. tolua( fieldName_Type[2], 'self->' .. fieldName_Type[1] ) .. ';' )
			end
			print( '  return ' .. #primitiveFields .. ';' )
			print( '}' )
			print()
		end

		local function plurify( name )
			if name:match( 'ices' ) then
				return name:sub( 1, -5 ) .. 'ixAt'
			elseif name:match( 'es' ) then
				return name:sub( 1, -3 ) .. 'At'
			elseif name:match( 's' ) then
				return name:sub( 1, -2 ) .. 'At'
			else
				return name .. 'At'
			end
		end

		-- Generate setters and getters for structs as metamethods
		-- For array-like fields generate indexed getter/setter with boundary checking
		for _, name_T_length in ipairs( structFields ) do
			local name, T, length = name_T_length[1], name_T_length[2], name_T_length[3]
			T = unalias( T )
			local getObj = '  ' .. structName .. '* obj = ' .. 'luaL_checkudata(L, 1, "' .. structName .. '");'
			local getIdx = '  int idx = luaL_checkinteger(L, 2);' 
			if length == "DYNAMIC" then
				getIdx = getIdx .. '\n  if (idx < 0) return luaL_error(L, "Index out of bounds %d", idx);'
			elseif length then
				getIdx = getIdx .. '\n  if (idx < 0 || idx > ' .. length .. ') return luaL_error(L, "Index out of bounds %d (max %d)", idx, ' .. length .. ');'
			end

			local name_ = length and plurify( name ) or name
			-- Setter
			print( 'static int ' .. prefix .. structName .. '_set_' .. name_ .. '(lua_State *L) {' )
			print( getObj )
			if length then
				print( getIdx )
				print( '  ' .. T .. ' ' .. name .. 'v = ' .. fromlua( T, 3 ) .. ';' )
				print( '  obj->' .. name .. '[idx] = ' .. name .. 'v;' )
			else
				print( '  ' .. T .. ' ' .. name .. ' = ' .. fromlua( T, 2 ) .. ';' )
				print( '  obj->' .. name .. ' = ' .. name .. ';' )
			end
			print( '  lua_pop(L, 1);' )
			print( '  return 1;' )
			print( '}' )
			print()

			-- Getter
			print( 'static int ' .. prefix .. structName .. '_get_' .. name_ .. '(lua_State *L) {' )
			print( getObj )
			if length then
				print( getIdx )
				print( '  ' .. T .. ' result = obj->' .. name .. '[idx];' )
			else
				print( '  ' .. T .. ' result = obj->' .. name .. ';' )
			end
			print( '  ' .. tolua( T ) .. ';' )
			print( '  return 1;' )
			print( '}' )
			print()

			if isPrimitiveStruct[T] then
				-- Setter unpacked
				print( 'static int ' .. prefix .. structName .. '_set_' .. name_ .. 'U(lua_State *L) {' )
				print( getObj )
				local argsU = {}
				if length then
					print( getIdx )
					local argsU = {}
					for i, name_type in ipairs( isPrimitiveStruct[T] ) do
						argsU[#argsU+1] = fromlua( name_type[2], i + 2 )
					end
					print( '  ' .. T .. ' ' .. name .. 'v = {' .. table.concat( argsU, ', ' ) .. '};' )
					print( '  obj->' .. name .. '[idx] = ' .. name .. 'v;' )
				else
					for i, name_type in ipairs( isPrimitiveStruct[T] ) do
						argsU[#argsU+1] = fromlua( name_type[2], i + 1 )
					end
					print( '  ' .. T .. ' ' .. name .. ' = {' .. table.concat( argsU, ', ' ) .. '};' )
					print( '  obj->' .. name .. ' = ' .. name .. ';' )
				end
				print( '  lua_pop(L, ' .. #argsU .. ');' )
				print( '  return 1;' )
				print( '}' )
				print()

				-- Getter unpacked
				print( 'static int ' .. prefix .. structName .. '_get_' .. name_ .. 'U(lua_State *L) {' )
				print( getObj )
				if length then
					print( getIdx )
					print( '  ' .. T .. ' result = obj->' .. name .. '[idx];' )
				else
					print( '  ' .. T .. ' result = obj->' .. name .. ';' )
				end
				local argsU = {}
				for i, name_type in ipairs( isPrimitiveStruct[T] ) do
					argsU[#argsU+1] = tolua( name_type[2], 'result.' .. name_type[1] )
				end
				print( '  ' .. table.concat( argsU, ';' ) .. ';' )
				print( '  return ' .. #argsU .. ';' )
				print( '}' )
				print()
			end
		end

		print( 'static const luaL_Reg ' .. prefix .. structName .. '[] = {' )
		for _, name_T_length in ipairs( structFields ) do
			local name = name_T_length[1]
			local T = unalias( name_T_length[2] )
			local length = name_T_length[3]
			name = length and plurify( name ) or name
			local uppercasedName = name:sub( 1, 1 ):upper() .. name:sub( 2 )
			print( '  {"get' .. uppercasedName .. '", ' .. prefix .. structName .. '_get_' .. name .. '},' )
			print( '  {"set' .. uppercasedName .. '", ' .. prefix .. structName .. '_set_' .. name .. '},' )
			if isPrimitiveStruct[T] then
				print( '  {"get' .. uppercasedName .. 'U", ' .. prefix .. structName .. '_get_' .. name .. 'U},' )
				print( '  {"set' .. uppercasedName .. 'U", ' .. prefix .. structName .. '_set_' .. name .. 'U},' )
			end
		end
		if isPrimitiveStruct[structName] then
			print( '  {"__eq", ' .. prefix .. structName .. '__eq},' )
			print( '  {"unpack", ' .. prefix .. structName .. '_unpack},' )
		end
		print( '  {NULL, NULL}' )
		print( '};' )
		print()
		print( 'static void ' .. prefix .. structName .. '_register(lua_State *L) {' )
		print( '  luaL_newmetatable(L, "' .. structName .. '");' )
  	print( '  lua_pushvalue(L, -1);' )
  	print( '  lua_setfield(L, -2, "__index");' )
  	print( '  luaL_setfuncs(L, ' .. prefix .. structName .. ', 0);' )
		print( '  lua_pop(L, 1);' )
		print( '}' )
		print()
	end
	print( 'LUAMOD_API int luaopen_' .. conf.libname .. '(lua_State *L) {' )
	print( '  luaL_newlib(L, ' .. prefix .. 'functions);' )
	for structName in pairs( defs.structs ) do
		structName = unalias( structName )
		print( '  ' .. prefix .. structName .. '_register(L);' )
	end
	for _, const in ipairs( defs.consts ) do
		local name, type_ = const[1], const[2]
		type_ = unalias( type_ )
		print( '  lua_push' .. (type_ == 'int' and 'integer' or 'number') .. '(L, ' .. name .. '); lua_setfield(L, -2, "' .. name .. '");' ) 
	end
	print( '  return 1;' )
	print( '}' )
end
